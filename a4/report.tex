\documentclass{article}
\usepackage{listings}

\usepackage{enumitem,amssymb}
\newlist{todolist}{itemize}{2}
\setlist[todolist]{label=$\square$}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\done}{\rlap{$\square$}{\raisebox{2pt}{\large\hspace{1pt}\cmark}}%
\hspace{-2.5pt}}
\newcommand{\wontfix}{\rlap{$\square$}{\large\hspace{1pt}\xmark}}



\author{Alexander De Laurentiis}
\title{Comp 442 A4}
\date{March 20, 2022}

\begin{document}
\maketitle

\section{List of Semantic Rules Implemented}
\begin{itemize}

\item Symbol creation phase
  \begin{todolist}
  \item [\done] 1 Each scope is considered a table.
  \item [\done] 2 Each declared class gets its own scope.
  \item [\done] 3 For each scope, if there is a parameter, var, or else declared it will be recored in that scope.
  \item [\done] 4 This is done for every declaration when traversing a scope.
  \item [\done] 5 Will give warning before using $asserta/1$ on a new variable from a scope if its already been asserted.
  \item [\done] 6 Will check if there is no body of a function then give the warning when parsing it.
  \item [\done] 7 Done.
  \item [\done] 8 Will give warning before using $asserta/1$ on a new variable from a scope if its already been asserted.
  \item [\wontfix]9 Gives warning if 2 functions have the same name but separate parameters.
  \end{todolist}

\item Semantic Checking phase
  \begin{todolist}

  \item [\wontfix] 10 Type Check expressions and the sub parts to all be 1 type, and same for assignment
  \item 11 Identifiers must be defined in a scope it is used.
  \item 12 Function calls use the right number of parameters, expressions as parameters are of the right type.
  \item 13 Array variables referred to have the correct quantity of dimmensions.
  \item 14 Circular clss dependencies reported.
  \item 15 The dot operator only being used on variables of the class type, and the right part must be a member of that class.
  \end{todolist}

\end{itemize}

\section{Design}
So with the programming language tools at my disposal with prolog, I decided to redo my entire ast output to be a uniform node(Name,[Children]) and terminal(Name,[Value]) format. This way it would be iteratable. Then I proceeded to make a set of predicates that would recursively iterate through the tree structure in a depth first left to right manner assuming full single threaded use.

For my symbol table I use prolog predicates which are asserted into the current session. Prolog is a language meant to traverse search spaces and make logical connections so it seemed most appropriate especially since I could mimic the behavior of a DB or table this way as well. Most entries are of the fomat symbol/4, symbol/5, or symbol/6 depending on the content it contains, but for each type of vardecl, function, or so on they are uniform in the order of info presented, such as a function being symbol(Scope,function,Returns,ID).

For the separate tests I made a predicate for each after the table was generated which would be used to test them then. That way it would pass through each, write to the output stream, then be all good.

\section{Tools Used}
For this assignment the only tools technically used was emacs as the programming environment with the ediprolog as a package to compile and run my code within buffers, and scryer-prolog set as the prolog distribution to be used in my configuration file. This was done for the conveniences and efficiency offered with scryer-prolog despite its lack of being a fully stable release, it is a recognized release and comparable to sisctus prolog which is completely proprietary while scryer-prolog is open source.

Sidenote of issues with the assert predicate occured and will be opening a github issue most likely or switching prolog dialects.

\end{document}