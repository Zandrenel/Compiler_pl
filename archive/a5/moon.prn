MOON listing of manualtest.m.

    1     0    org   29
    2    29    align   
    3    32    entry   
    4    32    j   scope10
    5    36 stop hlt   
    6    40    scope10   res   29
    7    69    sw -12(r14), 21
      >>>>> Error at `, 21': Register expected
    8    73    lw   -4(r13)
      >>>>> Error at `lw -4': Register expected
    9    77    add   r1,-4(r0),4
      >>>>> Error at `, -4': Register expected
   10    81 t2   res   4
   11    85    sw   t2(r14),
      >>>>> Error at `,  ': Register expected
   12    89    sw   j1(r14),t2
      >>>>> Error at `, t2': Register expected
   13    93    lw   -8(r14)
      >>>>> Error at `lw -8': Register expected
   14    97    jl   putstr,8
      >>>>> Error at `jl putstr': Register expected
   15   101    j stop      >>>>> Error at `stop  ': alignment error

MOON listing of moon/samples/lib.m.

    1   105 % A Simple MOON Library
    2   105 % Author: Peter Grogono
    3   105 % Last modified: 27 Jan 1995
    4   105 
    5   105 % Conventions
    6   105 %   r14 is the Stack Pointer
    7   105 %   -4(r14) is used to store the link, if necessary.
    8   105 %   -8(r14) contains the first argument.
    9   105 %   -12(r14) contains the second argument, and so on.
   10   105 %   r15 contains the link.
   11   105 %   r13 contains the result of a function.
   12   105 
   13   105 %   Strings are null terminated.  Strings are passed and returned to
   14   105 %   library functions as pointers.  It is the caller's responsibility to
   15   105 %   provide storage for strings.
   16   105 
   17   105 %   "->" is read "points to".
   18   105 
   19   105           align               % In case previous file misaligned
   20   108 
   21   108 % Write a string to stdout.
   22   108 % Entry: -8(r14) -> string argument.
   23   108 
   24   108 putstr    lw    r1,-8(r14)    % i := r1
   25   112           addi  r2,r0,0
   26   116 putstr1   lb    r2,0(r1)      % ch := B[i]
   27   120           ceqi  r3,r2,0
   28   124           bnz   r3,putstr2    % branch if ch = 0
   29   128           putc  r2
   30   132           addi  r1,r1,1       % i++
   31   136           j     putstr1
   32   140 putstr2   jr    r15
   33   144 
   34   144 % Read a string from stdin.  Read until CR (ASCII 13) but do not store
   35   144 % the CR.
   36   144 % Entry: -8(r14) -> buffer.
   37   144 
   38   144 getstr    lw    r1,-8(r14)    % i := r1
   39   148 getstr1   getc  r2            % get ch
   40   152           ceqi  r3,r2,10
   41   156           bnz   r3,getstr2    % branch if ch = CR
   42   160           sb    0(r1),r2      % B[i] := ch
   43   164           addi  r1,r1,1       % i++
   44   168           j     getstr1
   45   172 getstr2   sb    0(r1),r0      % B[i] := '\0'
   46   176           jr    r15
   47   180 
   48   180 % Convert string to integer.  Skip leading blanks.  Accept leading sign.
   49   180 % Entry: -8(r14) -> string.
   50   180 % Exit:  result in r13
   51   180 
   52   180 strint    addi  r13,r0,0      % R := 0 (result)
   53   184           addi  r4,r0,0       % S := 0 (sign)
   54   188           lw    r1,-8(r14)    % i := r1
   55   192           addi  r2,r0,0
   56   196 strint1   lb    r2,0(r1)      % ch := B[i]
   57   200           cnei  r3,r2,32
   58   204           bnz   r3,strint2    % branch if ch != blank
   59   208           addi  r1,r1,1
   60   212           j     strint1
   61   216 strint2   cnei  r3,r2,43
   62   220           bnz   r3,strint3    % branch if ch != "+"
   63   224           j     strint4
   64   228 strint3   cnei  r3,r2,45
   65   232           bnz   r3,strint5    % branch if ch != "-"
   66   236           addi  r4,r4,1       % S := 1
   67   240 strint4   addi  r1,r1,1       % i++
   68   244           lb    r2,0(r1)      % ch := B[i]
   69   248 strint5   clti  r3,r2,48
   70   252           bnz   r3,strint6    % branch if ch < "0"
   71   256           cgti  r3,r2,57
   72   260           bnz   r3,strint6    % branch if ch > "9"
   73   264           subi  r2,r2,48      % ch -= "0"
   74   268           muli  r13,r13,10    % R *= 10
   75   272           add   r13,r13,r2    % R += ch
   76   276           j     strint4
   77   280 strint6   ceqi  r3,r4,0
   78   284           bnz   r3,strint7    % branch if S = 0
   79   288           sub   r13,r0,r13    % R := -R
   80   292 strint7   jr    r15
   81   296 
   82   296 % Convert signed integer to string.
   83   296 % Entry: -8(r14) is the integer.
   84   296 %        -12(r14) -> buffer containing at least 12 bytes.
   85   296 % Exit:  r13 -> first character of result string.
   86   296 
   87   296 intstr    lw    r13,-12(r14)
   88   300           addi  r13,r13,11    % r13 points to end of buffer
   89   304           sb    0(r13),r0     % store terminator
   90   308           lw    r1,-8(r14)    % r1 := N (to be converted)
   91   312           addi  r2,r0,0       % S := 0 (sign)
   92   316           cgei  r3,r1,0
   93   320           bnz   r3,intstr1    % branch if N >= 0
   94   324           addi  r2,r2,1       % S := 1
   95   328           sub   r1,r0,r1      % N := -N
   96   332 intstr1   addi  r3,r1,0       % D := N (next digit)
   97   336           modi  r3,r3,10      % D mod= 10
   98   340           addi  r3,r3,48      % D += "0"
   99   344           subi  r13,r13,1     % i--
  100   348           sb    0(r13),r3     % B[i] := D
  101   352           divi  r1,r1,10      % N div= 10
  102   356           cnei  r3,r1,0
  103   360           bnz   r3,intstr1    % branch if N != 0
  104   364           ceqi  r3,r2,0
  105   368           bnz   r3,intstr2    % branch if S = 0
  106   372           subi  r13,r13,1     % i--
  107   376           addi  r3,r0,45
  108   380           sb    0(r13),r3     % B[i] := "-"
  109   384 intstr2   jr    r15
  110   388 
  111   388 % Return length of string.
  112   388 % Entry: -8(r14) -> string.
  113   388 % Exit:  r13 = length of string.
  114   388 
  115   388 lenstr   lw    r1,-8(r14)     % i -> string
  116   392          addi  r13,r0,0       % L := 0
  117   396          addi  r2,r0,0
  118   400 lenstr1  lb    r2,0(r1)       % ch := B[i]
  119   404          ceqi  r3,r2,0
  120   408          bnz   r3,lenstr2     % branch if ch = 0
  121   412          addi  r13,r13,1      % L++
  122   416          addi  r1,r1,1        % i++
  123   420          j     lenstr1
  124   424 lenstr2  jr    r15
  125   428 
  126   428 % Concatenate strings: Z := X + Y.
  127   428 % Entry:   -8(r14)  ->  X
  128   428 %         -12(r14)  ->  Y
  129   428 %         -16(r14)  ->  Z
  130   428 % The result string is assumed to be large enough to hold the result.
  131   428 
  132   428 strcat   lw    r1,-16(r14)    % r1 -> Z
  133   432          lw    r2,-8(r14)     % r2 -> X
  134   436          addi  r3,r0,0        % r3 = current character
  135   440 strcat1  lb    r3,0(r2)       % char from X
  136   444          ceqi  r4,r3,0
  137   448          bnz   r4,strcat2     % branch at end of X
  138   452          sb    0(r1),r3       % copy char to Z
  139   456          addi  r1,r1,1
  140   460          addi  r2,r2,1
  141   464          j     strcat1
  142   468 strcat2  lw    r2,-12(r14)    % r2 -> Y
  143   472 strcat3  lb    r3,0(r2)       % char from Y
  144   476          ceqi  r4,r3,0
  145   480          bnz   r4,strcat4     % branch at end of Y
  146   484          sb    0(r1),r3       % copy char to Z
  147   488          addi  r1,r1,1
  148   492          addi  r2,r2,1
  149   496          j     strcat3
  150   500 strcat4  sb    0(r1),r0       % Store terminator
  151   504          jr    r15
  152   508 
  153   508 % The string comparison functions all use strcmp, defined below.
  154   508 % They are all short; a smart compiler could generate this code
  155   508 % directly, avoiding the overhead of an extra level of function
  156   508 % call.
  157   508 % For each function:
  158   508 % Entry: -8(r14)  -> string A
  159   508 %        -12(r14) -> string B
  160   508 % Exit:  r13 = 1 for true and 0 for false.
  161   508 % Note that r11 is used for the link to avoid saving r15.
  162   508 
  163   508 streq    jl    r11,strcmp
  164   512          lw    r13,eq(r13)
  165   516          jr    r15
  166   520 eq       dw    1,0,0
  167   532 
  168   532 strne    jl    r11,strcmp
  169   536          lw    r13,ne(r13)
  170   540          jr    r15
  171   544 ne       dw    0,1,1
  172   556 
  173   556 strlt    jl    r11,strcmp
  174   560          lw    r13,lt(r13)
  175   564          jr    r15
  176   568 lt       dw    0,1,0
  177   580 
  178   580 strle    jl    r11,strcmp
  179   584          lw    r13,le(r13)
  180   588          jr    r15
  181   592 le       dw    1,1,0
  182   604 
  183   604 strgt    jl    r11,strcmp
  184   608          lw    r13,gt(r13)
  185   612          jr    r15
  186   616 gt       dw    0,0,1
  187   628 
  188   628 strge    jl    r11,strcmp
  189   632          lw    r13,ge(r13)
  190   636          jr    r15
  191   640 ge       dw    1,0,1
  192   652 
  193   652 % Compare strings.
  194   652 % Entry: -8(r14)  -> string A
  195   652 %        -12(r14) -> string B
  196   652 %             ( 0   if A = B
  197   652 % Exit: r13 = < 4   if A < B
  198   652 %             ( 8   if A > B
  199   652 % Note that r11 is the link.
  200   652 
  201   652 strcmp   lw    r1,-8(r14)
  202   656          lw    r2,-12(r14)
  203   660          addi  r3,r0,0
  204   664          addi  r4,r0,0
  205   668 strcmp1  lb    r3,0(r1)       % get A[i]
  206   672          lb    r4,0(r2)       % get B[j]
  207   676          ceqi  r5,r3,0
  208   680          bnz   r5,strcmp2     % branch if end of A
  209   684          ceqi  r5,r4,0
  210   688          bnz   r5,strcmp4     % branch if end of B
  211   692          ceq   r5,r3,r4
  212   696          bz    r5,strcmp3     % branch if A[i] != B[i]
  213   700          addi  r1,r1,1        % i++
  214   704          addi  r2,r2,1        % j++
  215   708          j     strcmp1
  216   712 strcmp2  ceqi  r5,r4,0
  217   716          bz    r5,strcmp5     % branch if not end of B
  218   720          addi  r13,r0,0       % A = B
  219   724          jr    r11
  220   728 strcmp3  clt   r5,r3,r4
  221   732          bnz   r5,strcmp5     % branch if A[i] < B[i]
  222   736 strcmp4  addi  r13,r0,8       % A > B
  223   740          jr    r11
  224   744 strcmp5  addi  r13,r0,4       % A < B
  225   748          jr    r11
  226   752 
  227   752 % String indexing: return the string S[M].  The value is returned as a
  228   752 % string rather than as a character for compatibility with other string
  229   752 % processing functions.  Also, we must distinguish the empty string
  230   752 % from a character.
  231   752 % Entry: -8(r14)  -> S
  232   752 %        -12(r14) -> M
  233   752 %        -16(r14) -> T, the output string.
  234   752 % Exit:  the output string contains the selected character, or is null.
  235   752 
  236   752 stridx   lw    r1,-8(r14)    % i
  237   756          lw    r2,-12(r14)
  238   760          lw    r3,-16(r14)
  239   764          subi  r2,r2,1
  240   768          addi  r4,r0,0
  241   772 stridx1  lb    r4,0(r1)      % ch := S[i]
  242   776          ceqi  r5,r4,0
  243   780          bnz   r5,stridx3    % branch if ch = 0
  244   784          cge   r5,r1,r2
  245   788          bnz   r5,stridx2    % branch if i >= M
  246   792          addi  r1,r1,1       % i++
  247   796          j     stridx1
  248   800 stridx2  sb    0(r3),r4      % T[0] := S[M]
  249   804          addi  r3,r3,1
  250   808 stridx3  sb    0(r3),r0      % T[k] := 0
  251   812          jr    r15
  252   816 
  253   816 % String indexing: return the string S[M..N].
  254   816 % Entry: -8(r14)  -> S
  255   816 %        -12(r14) -> M
  256   816 %        -16(r14) -> N
  257   816 %        -20(r14) -> T, the output string.
  258   816 % Exit:  the output string contains the selected substring, or is null.
  259   816 
  260   816 strsub   lw    r1,-8(r14)
  261   820          lw    r2,-12(r14)
  262   824          lw    r3,-16(r14)
  263   828          lw    r4,-20(r14)
  264   832          subi  r2,r2,1
  265   836          subi  r3,r3,1
  266   840          addi  r5,r0,0
  267   844 strsub1  lb    r5,0(r1)      % ch := S[i]
  268   848          ceqi  r6,r5,0
  269   852          bnz   r6,strsub3    % branch if ch = 0
  270   856          clt   r6,r1,r2
  271   860          bnz   r6,strsub2    % branch if i < M
  272   864          cgt   r6,r1,r3
  273   868          bnz   r6,strsub3    % branch if i > N
  274   872          sb    0(r3),r5      % T[k] := S[i]
  275   876          addi  r3,r3,1       % k++
  276   880 strsub2  addi  r1,r1,1       % i++
  277   884          j     strsub1
  278   888 strsub3  sb    0(r3),r0      % T[k] := 0
  279   892          jr    r15
  280   896 

